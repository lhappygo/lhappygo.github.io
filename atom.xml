<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>happygo&#39;s blog</title>
  
  
  <link href="http://lhappygo.github.io/atom.xml" rel="self"/>
  
  <link href="http://lhappygo.github.io/"/>
  <updated>2025-06-18T06:08:16.290Z</updated>
  <id>http://lhappygo.github.io/</id>
  
  <author>
    <name>happygo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis高可用架构解析</title>
    <link href="http://lhappygo.github.io/2022/06/27/Redis%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/"/>
    <id>http://lhappygo.github.io/2022/06/27/Redis%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/</id>
    <published>2022-06-27T12:25:20.000Z</published>
    <updated>2025-06-18T06:08:16.290Z</updated>
    
    
      
      
    <summary type="html">&lt;p&gt;Redis 高可用架构最常用、最成熟的方式是 &lt;strong&gt;哨兵模式（Sentinel）&lt;/strong&gt;。它是在主从复制基础上发展而来，专门为了解决主节点故障自动切换问题的官方解决方案。&lt;/p&gt;
&lt;p&gt;以下是对哨兵模式的详细解读：&lt;/p&gt;
&lt;h2 id=&quot;一、-基础：主</summary>
      
    
    
    
    <category term="Redis" scheme="http://lhappygo.github.io/categories/Redis/"/>
    
    
    <category term="Sentinel" scheme="http://lhappygo.github.io/tags/Sentinel/"/>
    
    <category term="Redis" scheme="http://lhappygo.github.io/tags/Redis/"/>
    
    <category term="高可用" scheme="http://lhappygo.github.io/tags/高可用/"/>
    
  </entry>
  
  <entry>
    <title>spring中项目中静态资源处理七种方式</title>
    <link href="http://lhappygo.github.io/2022/05/22/SpringBoot%E4%B8%AD7%E7%A7%8D%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E5%A4%84%E7%90%86%E6%8A%80%E5%B7%A7/"/>
    <id>http://lhappygo.github.io/2022/05/22/SpringBoot%E4%B8%AD7%E7%A7%8D%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E5%A4%84%E7%90%86%E6%8A%80%E5%B7%A7/</id>
    <published>2022-05-22T12:15:50.000Z</published>
    <updated>2025-06-17T07:58:01.606Z</updated>
    
    
      
      
    <summary type="html">&lt;p&gt;在Web应用开发中，静态资源（如CSS、JavaScript、图片等）的处理是一个基础但重要的环节。SpringBoot作为一个强大的应用框架，为开发者提供了多种灵活处理静态资源的方式。本文将介绍SpringBoot中7种静态资源处理技巧。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;利用默</summary>
      
    
    
    
    <category term="静态资源" scheme="http://lhappygo.github.io/categories/静态资源/"/>
    
    
    <category term="静态资源" scheme="http://lhappygo.github.io/tags/静态资源/"/>
    
    <category term="spring boot" scheme="http://lhappygo.github.io/tags/spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>Feign与OpenFeign详解</title>
    <link href="http://lhappygo.github.io/2022/03/27/Feign%E4%B8%8EOpenFeign%E8%A7%A3%E6%9E%90/"/>
    <id>http://lhappygo.github.io/2022/03/27/Feign%E4%B8%8EOpenFeign%E8%A7%A3%E6%9E%90/</id>
    <published>2022-03-27T12:25:20.000Z</published>
    <updated>2025-06-10T08:42:29.747Z</updated>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Feign与OpenFeign详解&quot;&gt;&lt;a href=&quot;#Feign与OpenFeign详解&quot; class=&quot;headerlink&quot; title=&quot;Feign与OpenFeign详解&quot;&gt;&lt;/a&gt;Feign与OpenFeign详解&lt;/h3&gt;&lt;h4 id=&quot;底层原理&quot;</summary>
      
    
    
    
    <category term="微服务" scheme="http://lhappygo.github.io/categories/微服务/"/>
    
    
    <category term="Feign" scheme="http://lhappygo.github.io/tags/Feign/"/>
    
    <category term="OpenFeign" scheme="http://lhappygo.github.io/tags/OpenFeign/"/>
    
  </entry>
  
  <entry>
    <title>Ribbon及Sentinel解析</title>
    <link href="http://lhappygo.github.io/2022/03/25/Ribbon%E5%8F%8ASentinel%E8%A7%A3%E6%9E%90/"/>
    <id>http://lhappygo.github.io/2022/03/25/Ribbon%E5%8F%8ASentinel%E8%A7%A3%E6%9E%90/</id>
    <published>2022-03-25T12:25:20.000Z</published>
    <updated>2025-06-10T08:29:34.555Z</updated>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Spring-Cloud-Alibaba-中-Ribbon-LoadBalancer-与-Sentinel-原理解析及配置指南&quot;&gt;&lt;a href=&quot;#Spring-Cloud-Alibaba-中-Ribbon-LoadBalancer-与-Sentinel-原理解</summary>
      
    
    
    
    <category term="微服务" scheme="http://lhappygo.github.io/categories/微服务/"/>
    
    
    <category term="Ribbon" scheme="http://lhappygo.github.io/tags/Ribbon/"/>
    
    <category term="Sentinel" scheme="http://lhappygo.github.io/tags/Sentinel/"/>
    
  </entry>
  
  <entry>
    <title>Feign和Dubbo组件分析</title>
    <link href="http://lhappygo.github.io/2022/03/22/Feign%E5%92%8CDubbo%E7%BB%84%E4%BB%B6%E5%88%86%E6%9E%90/"/>
    <id>http://lhappygo.github.io/2022/03/22/Feign%E5%92%8CDubbo%E7%BB%84%E4%BB%B6%E5%88%86%E6%9E%90/</id>
    <published>2022-03-22T12:15:50.000Z</published>
    <updated>2025-06-09T08:49:29.002Z</updated>
    
    
      
      
    <summary type="html">&lt;p&gt;在 Spring Cloud Alibaba 中，&lt;strong&gt;Feign&lt;/strong&gt; 和 &lt;strong&gt;Dubbo&lt;/strong&gt; 都是实现微服务间通信的关键组件，但它们的设计目标、协议支持和使用场景有显著差异。以下是两者的对比及适用场景分析：&lt;/p&gt;
&lt;hr</summary>
      
    
    
    
    <category term="微服务" scheme="http://lhappygo.github.io/categories/微服务/"/>
    
    
    <category term="微服务中间件" scheme="http://lhappygo.github.io/tags/微服务中间件/"/>
    
  </entry>
  
  <entry>
    <title>Docker日志实时查看和清理</title>
    <link href="http://lhappygo.github.io/2021/09/25/docker%E6%97%A5%E5%BF%97%E5%AE%9E%E6%97%B6%E6%9F%A5%E7%9C%8B%E4%B8%8E%E6%B8%85%E7%90%86/"/>
    <id>http://lhappygo.github.io/2021/09/25/docker%E6%97%A5%E5%BF%97%E5%AE%9E%E6%97%B6%E6%9F%A5%E7%9C%8B%E4%B8%8E%E6%B8%85%E7%90%86/</id>
    <published>2021-09-25T12:25:20.000Z</published>
    <updated>2025-06-09T08:49:28.996Z</updated>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Docker日志实时查看和清理&quot;&gt;&lt;a href=&quot;#Docker日志实时查看和清理&quot; class=&quot;headerlink&quot; title=&quot;Docker日志实时查看和清理&quot;&gt;&lt;/a&gt;Docker日志实时查看和清理&lt;/h1&gt;&lt;h2 id=&quot;一、docker-logs</summary>
      
    
    
    
    <category term="docker" scheme="http://lhappygo.github.io/categories/docker/"/>
    
    
    <category term="log" scheme="http://lhappygo.github.io/tags/log/"/>
    
  </entry>
  
  <entry>
    <title>jdk8链接mysql问题</title>
    <link href="http://lhappygo.github.io/2021/09/22/jdk8%E9%93%BE%E6%8E%A5mysql%E9%97%AE%E9%A2%98/"/>
    <id>http://lhappygo.github.io/2021/09/22/jdk8%E9%93%BE%E6%8E%A5mysql%E9%97%AE%E9%A2%98/</id>
    <published>2021-09-22T02:25:20.000Z</published>
    <updated>2025-06-09T08:49:29.009Z</updated>
    
    
      
      
    <summary type="html">&lt;p&gt;前几天发现一直跑的项目本地无法启动了：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;lin</summary>
      
    
    
    
    <category term="jdk8" scheme="http://lhappygo.github.io/categories/jdk8/"/>
    
    
    <category term="jdk8" scheme="http://lhappygo.github.io/tags/jdk8/"/>
    
  </entry>
  
  <entry>
    <title>HashMap各版本结构解读</title>
    <link href="http://lhappygo.github.io/2021/02/27/HashMap%E5%90%84%E7%89%88%E7%BB%93%E6%9E%84%E8%A7%A3%E8%AF%BB/"/>
    <id>http://lhappygo.github.io/2021/02/27/HashMap%E5%90%84%E7%89%88%E7%BB%93%E6%9E%84%E8%A7%A3%E8%AF%BB/</id>
    <published>2021-02-27T12:25:20.000Z</published>
    <updated>2025-06-17T07:29:07.981Z</updated>
    
    
      
      
    <summary type="html">&lt;p&gt;以下是针对不同Java版本中HashMap与ConcurrentHashMap的实现原理及数据结构的详细解析，结合JDK 1.7和JDK 1.8的核心差异进行对比：&lt;/p&gt;
&lt;p&gt;📊 一、HashMap 的实现演进&lt;br&gt;JDK 1.7：数组 + 链表&lt;/p&gt;
&lt;p&gt;数据</summary>
      
    
    
    
    <category term="HashMap" scheme="http://lhappygo.github.io/categories/HashMap/"/>
    
    
    <category term="hashMap" scheme="http://lhappygo.github.io/tags/hashMap/"/>
    
    <category term="ConcurrentHashMap" scheme="http://lhappygo.github.io/tags/ConcurrentHashMap/"/>
    
  </entry>
  
  <entry>
    <title>spring-boot中关于jpa异常问题</title>
    <link href="http://lhappygo.github.io/2020/11/24/spring-boot%E4%B8%AD%E5%BC%82%E5%B8%B8%E6%83%85%E5%86%B5%E8%AE%B0%E5%BD%95/"/>
    <id>http://lhappygo.github.io/2020/11/24/spring-boot%E4%B8%AD%E5%BC%82%E5%B8%B8%E6%83%85%E5%86%B5%E8%AE%B0%E5%BD%95/</id>
    <published>2020-11-24T09:12:43.000Z</published>
    <updated>2025-06-09T08:49:29.004Z</updated>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;spring-boot异常问题记录&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Bug in org.springframework.boot on 2.2.3.RELEASE version&lt;/p&gt;
&lt;p&gt;当我们使用spring-boot 的版本为2.2.3.RELE</summary>
      
    
    
    
    <category term="jpa" scheme="http://lhappygo.github.io/categories/jpa/"/>
    
    
    <category term="spring-boot" scheme="http://lhappygo.github.io/tags/spring-boot/"/>
    
    <category term="jpa" scheme="http://lhappygo.github.io/tags/jpa/"/>
    
    <category term="bug" scheme="http://lhappygo.github.io/tags/bug/"/>
    
  </entry>
  
  <entry>
    <title>Mysql存储引擎InnoDB是怎样解决幻读的</title>
    <link href="http://lhappygo.github.io/2020/09/19/Mysql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8EInnoDB%E6%98%AF%E6%80%8E%E6%A0%B7%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB/"/>
    <id>http://lhappygo.github.io/2020/09/19/Mysql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8EInnoDB%E6%98%AF%E6%80%8E%E6%A0%B7%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB/</id>
    <published>2020-09-19T12:12:43.000Z</published>
    <updated>2025-06-09T08:49:28.998Z</updated>
    
    
      
      
    <summary type="html">&lt;p&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.结论&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在RR的隔离级别下，InnoDB使用MVCC和next-key locks解决幻读，MVCC解决的是普通读（快照读）的幻读，next-key locks解决的是当前读情况下的幻读。&lt;/p&gt;
&lt;p&gt;&lt;</summary>
      
    
    
    
    <category term="事务" scheme="http://lhappygo.github.io/categories/事务/"/>
    
    
    <category term="事务" scheme="http://lhappygo.github.io/tags/事务/"/>
    
    <category term="幻读" scheme="http://lhappygo.github.io/tags/幻读/"/>
    
  </entry>
  
  <entry>
    <title>并发编程设置合适线程数</title>
    <link href="http://lhappygo.github.io/2020/09/06/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%B0%91%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%90%88%E9%80%82/"/>
    <id>http://lhappygo.github.io/2020/09/06/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%B0%91%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%90%88%E9%80%82/</id>
    <published>2020-09-06T02:39:50.000Z</published>
    <updated>2025-06-09T08:49:28.972Z</updated>
    
    
      
      
    <summary type="html">&lt;p&gt;并发编程创建多少个线程合适？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;并发编程在所有场景下都是快的吗？&lt;/li&gt;
&lt;li&gt;快怎样度量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需要从定性—-&amp;gt;定量的分析过程。&lt;/p&gt;
&lt;p&gt;正确的场景下、设置正确个数才能达到最优运行（充分利用CPU和I/O的利用</summary>
      
    
    
    
    <category term="thread" scheme="http://lhappygo.github.io/categories/thread/"/>
    
    
    <category term="线程数" scheme="http://lhappygo.github.io/tags/线程数/"/>
    
  </entry>
  
  <entry>
    <title>MySQL三大日志(bin log、redo log、undo log)</title>
    <link href="http://lhappygo.github.io/2020/09/05/MySQL%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97(bin%20log%E3%80%81redo%20log%E3%80%81undo%20log)/"/>
    <id>http://lhappygo.github.io/2020/09/05/MySQL%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97(bin%20log%E3%80%81redo%20log%E3%80%81undo%20log)/</id>
    <published>2020-09-05T06:28:12.000Z</published>
    <updated>2025-06-09T08:49:28.965Z</updated>
    
    
      
      
    <summary type="html">&lt;p&gt;日志是mysql数据库的重要组成部分，记录着数据库运行期间各种状态信息。mysql日志主要包括错误日志、查询日志、慢查询日志、事务日志、二进制日志几大类。作为后端开发，需要重点关注的是二进制日志(binlog)和事务日志(包括redo log和undo log)，接下来会详</summary>
      
    
    
    
    <category term="mysql" scheme="http://lhappygo.github.io/categories/mysql/"/>
    
    
    <category term="mysql" scheme="http://lhappygo.github.io/tags/mysql/"/>
    
    <category term="log" scheme="http://lhappygo.github.io/tags/log/"/>
    
  </entry>
  
  <entry>
    <title>GC收集器优劣势及适用场景</title>
    <link href="http://lhappygo.github.io/2020/08/29/GC%E4%BC%98%E5%8A%A3%E5%8A%BF%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>http://lhappygo.github.io/2020/08/29/GC%E4%BC%98%E5%8A%A3%E5%8A%BF%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</id>
    <published>2020-08-29T03:26:19.000Z</published>
    <updated>2025-06-09T08:49:28.982Z</updated>
    
    
      
      
    <summary type="html">&lt;p&gt;JVM垃圾收集器特点、优劣势及使用场景&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、常见垃圾收集器&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;新生代收集器&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Serial&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Par</summary>
      
    
    
    
    <category term="GC" scheme="http://lhappygo.github.io/categories/GC/"/>
    
    
    <category term="GC" scheme="http://lhappygo.github.io/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>CAS算法及ABA问题</title>
    <link href="http://lhappygo.github.io/2020/03/07/CAS%E7%AE%97%E6%B3%95%E5%8F%8A%E5%AD%98%E5%9C%A8%E9%97%AE%E9%A2%98/"/>
    <id>http://lhappygo.github.io/2020/03/07/CAS%E7%AE%97%E6%B3%95%E5%8F%8A%E5%AD%98%E5%9C%A8%E9%97%AE%E9%A2%98/</id>
    <published>2020-03-07T07:10:22.000Z</published>
    <updated>2025-06-09T08:49:28.977Z</updated>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;CAS算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CAS（Compare And Swap)比较并交换，乐观锁的思想，认为总可成功完成操作，在多线程同时使用CAS操作一个变量时，只会有一个线程获得操作更新的权利，其他的都会失败，失败的线程不会被挂起，仅被告知失败，</summary>
      
    
    
    
    <category term="CAS" scheme="http://lhappygo.github.io/categories/CAS/"/>
    
    
    <category term="CAS" scheme="http://lhappygo.github.io/tags/CAS/"/>
    
    <category term="乐观锁" scheme="http://lhappygo.github.io/tags/乐观锁/"/>
    
  </entry>
  
  <entry>
    <title>AQS独占模式解析</title>
    <link href="http://lhappygo.github.io/2019/09/07/AbstractQueuedSynchronized(%E4%BA%8C%EF%BC%89/"/>
    <id>http://lhappygo.github.io/2019/09/07/AbstractQueuedSynchronized(%E4%BA%8C%EF%BC%89/</id>
    <published>2019-09-07T04:10:18.000Z</published>
    <updated>2025-06-09T08:49:28.989Z</updated>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;AbstractQueuedSynchronized独占模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;概述：独占模式下节点怎样进入同步队列排队，离开同步队列前会进行哪些操作。AQS在独占模式和共享模式下获取锁分别提供了三种方式&lt;br&gt;不响应线程中断获取，响应县城中断</summary>
      
    
    
    
    <category term="AQS" scheme="http://lhappygo.github.io/categories/AQS/"/>
    
    
    <category term="AQS" scheme="http://lhappygo.github.io/tags/AQS/"/>
    
    <category term="Lock" scheme="http://lhappygo.github.io/tags/Lock/"/>
    
  </entry>
  
  <entry>
    <title>Java中AQS</title>
    <link href="http://lhappygo.github.io/2019/08/10/AbstractQueuedSynchronized/"/>
    <id>http://lhappygo.github.io/2019/08/10/AbstractQueuedSynchronized/</id>
    <published>2019-08-10T07:39:29.000Z</published>
    <updated>2025-06-09T08:49:28.974Z</updated>
    
    
      
      
    <summary type="html">&lt;p&gt;1.AbstractQueuedSynchronized&lt;/p&gt;
&lt;p&gt;ReentrantLock实现了一个内部类Sync,该内部类继承了AQS，所有锁机制的实现都依赖于Sync这个内部类，ReentrantLock的实现依赖于AQS类。类似的还有CountDownLatc</summary>
      
    
    
    
    <category term="AQS" scheme="http://lhappygo.github.io/categories/AQS/"/>
    
    
    <category term="AQS" scheme="http://lhappygo.github.io/tags/AQS/"/>
    
  </entry>
  
  <entry>
    <title>java中日期格式规范</title>
    <link href="http://lhappygo.github.io/2019/07/27/java%E4%B8%AD%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E8%A7%84%E8%8C%83/"/>
    <id>http://lhappygo.github.io/2019/07/27/java%E4%B8%AD%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E8%A7%84%E8%8C%83/</id>
    <published>2019-07-27T06:32:30.000Z</published>
    <updated>2025-06-09T08:49:29.007Z</updated>
    
    
      
      
    <summary type="html">&lt;p&gt;日期格式的规范：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.日期格式化时，传入pattern中表示年份统一使用小写的y。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;desc:日期格式化，yyyy表示当天所在的年，而大写的YYYY代表是 week in which year（jdk7之后引入的</summary>
      
    
    
    
    <category term="日期格式" scheme="http://lhappygo.github.io/categories/日期格式/"/>
    
    
    <category term="日期格式" scheme="http://lhappygo.github.io/tags/日期格式/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot中定时任务配置多线程</title>
    <link href="http://lhappygo.github.io/2019/05/18/SpringBoot%E4%B8%AD%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E9%85%8D%E7%BD%AE%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C/"/>
    <id>http://lhappygo.github.io/2019/05/18/SpringBoot%E4%B8%AD%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E9%85%8D%E7%BD%AE%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C/</id>
    <published>2019-05-18T10:19:23.000Z</published>
    <updated>2025-06-09T08:49:28.997Z</updated>
    
    
      
      
    <summary type="html">&lt;p&gt;SpringBoot中定时任务在不配置线程池时，默认是单线程执行的。系统中配置多个定时任务，会按照列队进行执行。这样执行效率低，可能对Corn配置的存在影响。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//多线程执行定时任务
@Slf4j
@Configuration
public c</summary>
      
    
    
    
    <category term="定时任务" scheme="http://lhappygo.github.io/categories/定时任务/"/>
    
    
    <category term="定时任务" scheme="http://lhappygo.github.io/tags/定时任务/"/>
    
    <category term="多线程" scheme="http://lhappygo.github.io/tags/多线程/"/>
    
    <category term="SpringBoot" scheme="http://lhappygo.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>LockSuport简述-1</title>
    <link href="http://lhappygo.github.io/2019/03/17/Java%20LockSupport/"/>
    <id>http://lhappygo.github.io/2019/03/17/Java%20LockSupport/</id>
    <published>2019-03-17T10:50:19.000Z</published>
    <updated>2025-06-09T08:49:28.995Z</updated>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;LockSupport是线程阻塞原语，用来阻塞线程和唤醒线程。每个使用LockSupport的线程都会与一个许可permit关联：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如果该许可可用，并且可在线程中使用，则调用park()将</summary>
      
    
    
    
    <category term="lock" scheme="http://lhappygo.github.io/categories/lock/"/>
    
    
    <category term="lock" scheme="http://lhappygo.github.io/tags/lock/"/>
    
  </entry>
  
  <entry>
    <title>java中的锁(偏向锁、轻量锁..）</title>
    <link href="http://lhappygo.github.io/2019/03/09/java%E4%B8%AD%E7%9A%84%E9%94%81(%E5%81%8F%E5%90%91%E9%94%81%E3%80%81%E8%BD%BB%E9%87%8F%E9%94%81..%EF%BC%89/"/>
    <id>http://lhappygo.github.io/2019/03/09/java%E4%B8%AD%E7%9A%84%E9%94%81(%E5%81%8F%E5%90%91%E9%94%81%E3%80%81%E8%BD%BB%E9%87%8F%E9%94%81..%EF%BC%89/</id>
    <published>2019-03-09T07:29:15.000Z</published>
    <updated>2025-06-09T08:49:28.963Z</updated>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;CAS操作：&lt;/strong&gt;&lt;br&gt;compareAndSwap,比较并替换，实现并发算法常用技术&lt;/p&gt;
&lt;p&gt;CAS需要有3个操作数：&lt;br&gt;内存地址V,旧预期值A，即将更新的目标值B。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;锁的升级：&lt;/strong&gt;&lt;/p</summary>
      
    
    
    
    <category term="lock" scheme="http://lhappygo.github.io/categories/lock/"/>
    
    
    <category term="lock" scheme="http://lhappygo.github.io/tags/lock/"/>
    
  </entry>
  
</feed>
